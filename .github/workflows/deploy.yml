name: Deploy to Production

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  DOCKER_COMPOSE_FILE: docker-compose.yml
  DB_USER: finance
  DB_PASSWORD: finance
  DB_NAME: finance
  APP_PORT: 6000
  HEALTH_CHECK_RETRIES: 3
  HEALTH_CHECK_INTERVAL: 10

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Debug Environment
        run: |
          echo "SSH_HOST: ${{ secrets.SSH_HOST }}"
          echo "SSH_USERNAME: ${{ secrets.SSH_USERNAME }}"
          echo "DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}"

      - name: Deploy to remote server
        if: contains(github.event_name, 'push')
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USERNAME }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            set -e
            echo "Current directory: $(pwd)"
            echo "Deploy path: ${{ secrets.DEPLOY_PATH }}"

            # Navigate to deploy directory
            cd ${{ secrets.DEPLOY_PATH }}

            # Pull latest changes
            git pull origin main

            # Stop existing containers
            docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} down -v || true

            # Build and start containers
            DB_USER=${{ env.DB_USER }} \
            DB_PASSWORD=${{ env.DB_PASSWORD }} \
            DB_NAME=${{ env.DB_NAME }} \
            docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} build --no-cache

            DB_USER=${{ env.DB_USER }} \
            DB_PASSWORD=${{ env.DB_PASSWORD }} \
            DB_NAME=${{ env.DB_NAME }} \
            docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} up -d

            # Wait for PostgreSQL to be ready
            for i in $(seq 1 ${{ env.HEALTH_CHECK_RETRIES }}); do
              if docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} exec -T postgres pg_isready -U ${{ env.DB_USER }}; then
                break
              fi
              if [ $i -eq ${{ env.HEALTH_CHECK_RETRIES }} ]; then
                echo "PostgreSQL failed to become ready"
                exit 1
              fi
              sleep ${{ env.HEALTH_CHECK_INTERVAL }}
            done

            # Run migrations and setup
            DB_USER=${{ env.DB_USER }} \
            DB_PASSWORD=${{ env.DB_PASSWORD }} \
            DB_NAME=${{ env.DB_NAME }} \
            docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} exec -T app npm run db:migrate

            DB_USER=${{ env.DB_USER }} \
            DB_PASSWORD=${{ env.DB_PASSWORD }} \
            DB_NAME=${{ env.DB_NAME }} \
            docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} exec -T app npm run db:ensure-demo

            # Health check
            for i in $(seq 1 ${{ env.HEALTH_CHECK_RETRIES }}); do
              if curl -f http://localhost:${{ env.APP_PORT }}/; then
                echo "Application is healthy"
                exit 0
              fi
              if [ $i -eq ${{ env.HEALTH_CHECK_RETRIES }} ]; then
                echo "Application failed health check"
                exit 1
              fi
              sleep ${{ env.HEALTH_CHECK_INTERVAL }}
            done

      - name: Deploy locally
        if: contains(github.event_name, 'push')
        run: |
          set -e
          docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} down -v || true

          DB_USER=${{ env.DB_USER }} \
          DB_PASSWORD=${{ env.DB_PASSWORD }} \
          DB_NAME=${{ env.DB_NAME }} \
          docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} build --no-cache

          DB_USER=${{ env.DB_USER }} \
          DB_PASSWORD=${{ env.DB_PASSWORD }} \
          DB_NAME=${{ env.DB_NAME }} \
          docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} up -d

          # Wait for PostgreSQL to be ready
          for i in $(seq 1 ${{ env.HEALTH_CHECK_RETRIES }}); do
            if docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} exec -T postgres pg_isready -U ${{ env.DB_USER }}; then
              break
            fi
            if [ $i -eq ${{ env.HEALTH_CHECK_RETRIES }} ]; then
              echo "PostgreSQL failed to become ready"
              exit 1
            fi
            sleep ${{ env.HEALTH_CHECK_INTERVAL }}
          done

          # Run migrations and setup
          DB_USER=${{ env.DB_USER }} \
          DB_PASSWORD=${{ env.DB_PASSWORD }} \
          DB_NAME=${{ env.DB_NAME }} \
          docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} exec -T app npm run db:migrate

          DB_USER=${{ env.DB_USER }} \
          DB_PASSWORD=${{ env.DB_PASSWORD }} \
          DB_NAME=${{ env.DB_NAME }} \
          docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} exec -T app npm run db:ensure-demo

          # Health check
          for i in $(seq 1 ${{ env.HEALTH_CHECK_RETRIES }}); do
            if curl -f http://localhost:${{ env.APP_PORT }}/; then
              echo "Application is healthy"
              exit 0
            fi
            if [ $i -eq ${{ env.HEALTH_CHECK_RETRIES }} ]; then
              echo "Application failed health check"
              exit 1
            fi
            sleep ${{ env.HEALTH_CHECK_INTERVAL }}
          done

name: Deploy to Production

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  DOCKER_COMPOSE_FILE: docker-compose.yml
  APP_PORT: 6000
  HEALTH_CHECK_RETRIES: 3
  HEALTH_CHECK_INTERVAL: 10

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Debug Environment
        run: |
          echo "SSH_HOST: ${{ secrets.SSH_HOST }}"
          echo "SSH_USERNAME: ${{ secrets.SSH_USERNAME }}"
          echo "DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}"
          echo "DB_USER: ${{ secrets.DB_USER }}"
          echo "DB_PASSWORD: ${{ secrets.DB_PASSWORD }}"
          echo "DB_NAME: ${{ secrets.DB_NAME }}"

      - name: Deploy to remote server
        if: contains(github.event_name, 'push')
        uses: JimCronqvist/action-ssh@master
        with:
          hosts: ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }}
          privateKey: ${{ secrets.SSH_PRIVATE_KEY }}
          command: |
            set -e
            echo "Current directory: $(pwd)"
            echo "Deploy path: ${{ secrets.DEPLOY_PATH }}"

            # Navigate to deploy directory
            cd ${{ secrets.DEPLOY_PATH }}

            # Pull latest changes
            git pull origin main

            # Stop existing containers
            docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} down -v || true

            # Build and start containers
            export DB_USER="${{ secrets.DB_USER }}"
            export DB_PASSWORD="${{ secrets.DB_PASSWORD }}"
            export DB_NAME="${{ secrets.DB_NAME }}"

            echo "Building with database user: $DB_USER"
            docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} build --no-cache

            echo "Starting containers with database user: $DB_USER"
            docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} up -d

            # Wait for PostgreSQL to be ready
            for i in $(seq 1 ${{ env.HEALTH_CHECK_RETRIES }}); do
              if docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} exec -T postgres pg_isready -U $DB_USER; then
                echo "PostgreSQL is ready"
                break
              fi
              if [ $i -eq ${{ env.HEALTH_CHECK_RETRIES }} ]; then
                echo "PostgreSQL failed to become ready"
                exit 1
              fi
              echo "Waiting for PostgreSQL... attempt $i of ${{ env.HEALTH_CHECK_RETRIES }}"
              sleep ${{ env.HEALTH_CHECK_INTERVAL }}
            done

            # Run migrations and setup
            echo "Running database migrations"
            docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} exec -T app npm run db:migrate

            echo "Setting up demo content"
            docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} exec -T app npm run db:ensure-demo

            # Health check
            for i in $(seq 1 ${{ env.HEALTH_CHECK_RETRIES }}); do
              if curl -f http://localhost:${{ env.APP_PORT }}/; then
                echo "Application is healthy"
                exit 0
              fi
              if [ $i -eq ${{ env.HEALTH_CHECK_RETRIES }} ]; then
                echo "Application failed health check"
                exit 1
              fi
              echo "Waiting for application to become healthy... attempt $i of ${{ env.HEALTH_CHECK_RETRIES }}"
              sleep ${{ env.HEALTH_CHECK_INTERVAL }}
            done

      - name: Deploy locally
        if: contains(github.event_name, 'push')
        run: |
          set -e
          docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} down -v || true

          # Export DB credentials as environment variables
          export DB_USER="${{ secrets.DB_USER }}"
          export DB_PASSWORD="${{ secrets.DB_PASSWORD }}"
          export DB_NAME="${{ secrets.DB_NAME }}"

          echo "Building with database user: $DB_USER"
          docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} build --no-cache

          echo "Starting containers with database user: $DB_USER"
          docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} up -d

          # Wait for PostgreSQL to be ready
          for i in $(seq 1 ${{ env.HEALTH_CHECK_RETRIES }}); do
            if docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} exec -T postgres pg_isready -U $DB_USER; then
              echo "PostgreSQL is ready"
              break
            fi
            if [ $i -eq ${{ env.HEALTH_CHECK_RETRIES }} ]; then
              echo "PostgreSQL failed to become ready"
              exit 1
            fi
            echo "Waiting for PostgreSQL... attempt $i of ${{ env.HEALTH_CHECK_RETRIES }}"
            sleep ${{ env.HEALTH_CHECK_INTERVAL }}
          done

          # Run migrations and setup
          echo "Running database migrations"
          docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} exec -T app npm run db:migrate

          echo "Setting up demo content"
          docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} exec -T app npm run db:ensure-demo

          # Health check
          for i in $(seq 1 ${{ env.HEALTH_CHECK_RETRIES }}); do
            if curl -f http://localhost:${{ env.APP_PORT }}/; then
              echo "Application is healthy"
              exit 0
            fi
            if [ $i -eq ${{ env.HEALTH_CHECK_RETRIES }} ]; then
              echo "Application failed health check"
              exit 1
            fi
            echo "Waiting for application to become healthy... attempt $i of ${{ env.HEALTH_CHECK_RETRIES }}"
            sleep ${{ env.HEALTH_CHECK_INTERVAL }}
          done
